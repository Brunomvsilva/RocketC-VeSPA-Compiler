# RocketC ‚Äì A VeSPA C Compiler

_A C compiler developed for educational purposes, targeting the VeSPA RISC architecture and generating VeSPA assembly and machine code._

---

## üìå Table of Contents
- [Overview](#overview)
- [Compiler Architecture](#compiler-architecture)
- [Repository Structure](#repository-structure)
- [How to Build & Run](#how-to-build--run)
- [Compilation Flow](#compilation-flow)
- [Features & Limitations](#features--limitations)
- [Future Improvements](#future-improvements)
- [Authors](#authors)

---

## Introduction

**RocketC** is a custom C compiler developed specifically for the **VeSPA processor**, a RISC-based System-on-Chip implemented on FPGA.

It compiles C programs into **VeSPA Assembly** and **machine code**, which can then be executed on the hardware.

The goal of this project is to design and implement a full compilation flow capable of generating executable code for the VeSPA architecture, enabling high-level programming on a custom-built CPU.

---

## TEAM  

‚û°Ô∏è This project was developed by a team of 20 students as part of the Embedded Systems course. 

‚û°Ô∏è The class was organized into three groups, which rotated roles throughout the semester to cover different stages of the development process

‚û°Ô∏è The roles were:

- Rocket C Compiler Frontend - Current Repository  
- Rocket C Compiler Backend - Current Repository
- [CPU Pipeline (SoC Team)](https://github.com/Brunomvsilva/VESPA-SoC.git)  

---

## Repository Components

| Folder | Description |
|--------|-------------|
| [`Assembler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Assembler) | Contains Assembler code, which turns **VeSPA Assembly into machine code** (`.coe` / binary format). |
| [`Compiler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Compiler) | Contains the **RocketC VeSPA Compiler code** |
| [`Instruction Scheduler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Instruction%20Scheduler) | Includes the **Instruction Scheduler**, used to reduce hazards generated by the compiler in VeSPA code. |
| [`Simulator/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Simulator) | **RocketSim - Software simulator for the VeSPA CPU**, capable of executing assembly/binary programs step-by-step. |
| [`Reports and Presentation/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Reports%20and%20Presentation) | Includes the **project report and presentation slides**. |


---

## Tools & Programming Language Used

**Programming Language** - C

| Tool        | Purpose                                          |
|-------------|--------------------------------------------------|
| **VS Code** | Main development environment     |
| **GCC**     | C compiler used to develop the VESPA compiler     |
| **GNU Flex**    | Lexical analyzer generator (tokenizer)           |
| **GNU Bison**   | Parser generator for syntax, grammar definition and AST build |
| **Makefile**| Build automation and project compilation         |

---

## Compiler Overview

<p align="center">
  <img src="Images/OverviewCompiler.png" alt="Compiler%20Overview" width="600">
</p>

---

## Lexical Analysis

Lexical analysis is the **first stage of the compiler**. Its role is to read the input C source code and convert it into a sequence of **tokens**.
Anything that doesn't match the expected patterns of the language is reported as a **lexical error**.
As stated before, this was implemented using the open source GNU Flex tool.

**GNU Flex**

- Flex reads a specification file (`.l`) containing **regular expressions for tokens**.
- It generates a C source file that scans the input program and **produces tokens**.
- These tokens are then passed to the syntax parser (Bison).

**Why Flex is used:**
- Fast and efficient token scanning  
- Easy integration with C and Bison/Yacc  
- Supports regular expressions for easy token definition  
- Commonly used in real compilers (GCC, Clang, etc.)

The following elements were defined in the **lexer**:  
**reserved words**, **special symbols**, and their corresponding **regular expressions**.

<p align="center">
  <img src="Images/LexerReservedWords.png" alt="Reserved Words" width="36%">
  <img src="Images/LexerSpecialSymbols.png" alt="Special Symbols" width="26%">
  <img src="Images/LexerRegularExp.png" alt="Regular Expressions" width="31%">
</p>

> **Limitations:**  
> The following C features are **not supported** in this version of the compiler:  
> `struct`, `typedef`, `enum`, `union`, `sizeof`, `->`, `.`

### Complete Lexer File (`LexScanner.l`)

The full lexer implementation for the VeSPA C Compiler is available here:  
[`Compiler/Lexer/LexScanner.l`](Compiler/Lexer/LexScanner.l)

---

## Syntatic Analysis

Syntax analysis (or **parsing**) is the **second stage of the compiler**. Its purpose is to take the tokens generated by the lexer and verify whether they follow the **grammar rules of the C language**.

If the code is syntactically correct, the parser constructs a **Parse Tree** or **Abstract Syntax Tree (AST)**.  
If the input does not follow the grammar, a **syntax error** is reported.

---

### GNU Bison

This stage is implemented using **GNU Bison**, a parser generator that works alongside Flex.

- Bison reads a grammar specification file (`.y`) written in a BNF-like (Backus‚ÄìNaur Form) syntax.

### Why Bison is used:

- Automatically generates efficient LR parsers  
- Integrates seamlessly with **Flex**  
- ‚úÖ Supports complex grammar definitions  
- ‚úÖ Used in real compilers like **GCC**, making it ideal for learning and development


### ‚úÖ Is Bison Bottom-Up?

Yes. **GNU Bison is a bottom-up parser generator**.  
More specifically, it generates an **LR parser** (by default LR(1)), which works as follows:

- Reads tokens from the lexer (Flex) **from left to right**
- **Shifts** tokens onto a parsing stack
- **Reduces** groups of tokens according to grammar rules
- Repeats this process until everything is reduced into the **start symbol** of the grammar

This means the parser builds the structure of the program **from the bottom (tokens) to the top (full syntax tree)**.

---

### ‚úÖ Why LR / Bottom-Up Parsing?

- ‚úî Can parse a **wider range of grammars** than top-down (LL) parsers  
- ‚úî Naturally handles **left recursion**  
- ‚úî Provides **stronger syntax error detection**  
- ‚úî Used in real compilers like **GCC**, making it ideal for **C-like languages**




---

### Supported Syntax Features

---

### Complete Parser File (`SyntaxParser.y`)

The complete grammar specifications are implemented in:  
[`Compiler/Parser/SyntaxParser.y`](Compiler/Parser/SyntaxParser.y)




