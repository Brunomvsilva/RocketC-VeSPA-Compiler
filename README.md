# RocketC ‚Äì A VeSPA C Compiler

_A C compiler developed for educational purposes, targeting the VeSPA RISC architecture and generating VeSPA assembly and machine code._

---

## üìå Table of Contents
- [Overview](#overview)
- [Compiler Architecture](#compiler-architecture)
- [Repository Structure](#repository-structure)
- [How to Build & Run](#how-to-build--run)
- [Compilation Flow](#compilation-flow)
- [Features & Limitations](#features--limitations)
- [Future Improvements](#future-improvements)
- [Authors](#authors)

---

## Introduction

**RocketC** is a custom C compiler developed specifically for the **VeSPA processor**, a RISC-based System-on-Chip implemented on FPGA.

It compiles C programs into **VeSPA Assembly** and **machine code**, which can then be executed on the hardware.

The goal of this project is to design and implement a full compilation flow capable of generating executable code for the VeSPA architecture, enabling high-level programming on a custom-built CPU.

---

## TEAM  

‚û°Ô∏è This project was developed by a team of 20 students as part of the Embedded Systems course. 

‚û°Ô∏è The class was organized into three groups, which rotated roles throughout the semester to cover different stages of the development process

‚û°Ô∏è The roles were:

- Rocket C Compiler Frontend - Current Repository  
- Rocket C Compiler Backend - Current Repository
- [CPU Pipeline (SoC Team)](https://github.com/Brunomvsilva/VESPA-SoC.git)  

---

## Repository Components

| Folder | Description |
|--------|-------------|
| [`Assembler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Assembler) | Contains Assembler code, which turns **VeSPA Assembly into machine code** (`.coe` / binary format). |
| [`Compiler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Compiler) | Contains the **RocketC VeSPA Compiler code** |
| [`Instruction Scheduler/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Instruction%20Scheduler) | Includes the **Instruction Scheduler**, used to reduce hazards generated by the compiler in VeSPA code. |
| [`Simulator/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Simulator) | **RocketSim - Software simulator for the VeSPA CPU**, capable of executing assembly/binary programs step-by-step. |
| [`Reports and Presentation/`](https://github.com/Brunomvsilva/RocketC-VeSPA-Compiler/tree/main/Reports%20and%20Presentation) | Includes the **project report and presentation slides**. |


---

## Tools & Programming Language Used

**Programming Language** - C

| Tool        | Purpose                                          |
|-------------|--------------------------------------------------|
| **VS Code** | Main development environment     |
| **GCC**     | C compiler used to develop the VESPA compiler     |
| **GNU Flex**    | Lexical analyzer generator (tokenizer)           |
| **GNU Bison**   | Parser generator for syntax, grammar definition and AST build |
| **Makefile**| Build automation and project compilation         |

---

## Compiler Overview

<p align="center">
  <img src="Images/OverviewCompiler.png" alt="Compiler%20Overview" width="600">
</p>

---

## Lexical Analysis

Lexical analysis is the **first stage of the compiler**. Its role is to read the input C source code and convert it into a sequence of **tokens**.
Anything that doesn't match the expected patterns of the language is reported as a **lexical error**.
As stated before, this was implemented using the open source GNU Flex tool.

**GNU Flex**

- Flex reads a specification file (`.l`) containing **regular expressions for tokens**.
- It generates a C source file that scans the input program and **produces tokens**.
- These tokens are then passed to the syntax parser (Bison).

**Why Flex is used:**
- Fast and efficient token scanning  
- Easy integration with C and Bison/Yacc  
- Supports regular expressions for easy token definition  
- Commonly used in real compilers (GCC, Clang, etc.)

The following elements were defined in the **lexer**:  
**reserved words**, **special symbols**, and their corresponding **regular expressions**.

<p align="center">
  <img src="Images/LexerReservedWords.png" alt="Reserved Words" width="36%">
  <img src="Images/LexerSpecialSymbols.png" alt="Special Symbols" width="26%">
  <img src="Images/LexerRegularExp.png" alt="Regular Expressions" width="31%">
</p>

> **Limitations:**  
> The following C features are **not supported** in this version of the compiler:  
> `struct`, `typedef`, `enum`, `union`, `sizeof`, `->`, `.`

### Complete Lexer File (`LexScanner.l`)

The full lexer implementation for the VeSPA C Compiler is available here:  
[`Compiler/Lexer/LexScanner.l`](Compiler/Lexer/LexScanner.l)

---

## Syntatic Analysis

Syntax analysis (or **parsing**) is the **second stage of the compiler**. Its purpose is to take the tokens generated by the lexer and verify whether they follow the **grammar rules of the C language**.

If the code is syntactically correct, the parser constructs a **Parse Tree** or **Abstract Syntax Tree (AST)**.  
If the input does not follow the grammar, a **syntax error** is reported.

---

### GNU Bison

This stage is implemented using **GNU Bison**, a parser generator that works alongside Flex.
**GNU Bison is a bottom-up parser generator**. It reads a grammar specification file (`.y`) written in BNF (Backus‚ÄìNaur Form) syntax.

It generates a **bottom-up** **LR parser**, which works as follows:

- Reads tokens from the lexer **from left to right**
- **Shifts** tokens onto a parsing stack
- **Reduces** groups of tokens according to grammar rules
- Repeats this process until everything is reduced into the **start symbol** of the grammar

### Why Bison is used:

- Integrates with **Flex**  
- Supports complex grammar definitions  
- Used in real compilers like **GCC**


### Grammar Rules

The complete grammar specifications are implemented in:  
[`Compiler/Parser/SyntaxParser.y`](Compiler/Parser/SyntaxParser.y)

### AST Nodes

This table details different types of nodes commonly found in an AST, along with their specific child nodes. Each row represents a type of node, and the columns indicate the different types of child nodes.

<p align="center">
  <img src="Images/PArserNodes.png" alt="PArserNodes.png" width="650">
</p>

---

## Semantic Analysis

Semantic analysis is the **third stage of the compiler**.  
While syntax analysis checks if the structure of the program is valid, semantic analysis ensures it also makes **logical sense according to C language rules**.

It verifies:
- Variables are **declared before use**
- **Type compatibility** in expressions and assignments
- **Scope rules** are followed
- Functions are called with the **correct number and types of arguments**

---

### üîπ Symbol Table & Scoped Organization

The compiler uses a **scoped symbol table system**, implemented with **hash tables** for fast insertion and lookup of identifiers.

Each block of code (global, function, or `{ }` block) has its own symbol table, and these tables are organized in a **hierarchical structure**.

<p align="center">
  <img src="Images/ScopedSymbolTable.png" alt="Scoped Symbol Table" width="650">
</p>

<p align="center">
  <img src="Images/SymbTableExxample.png" alt="Symbol Table Example" width="650">
</p>

#### Key Features:
- Each symbol is associated with **the scope in which it was declared**
- Uses **nearest scope resolution** ‚Äì the compiler searches the current scope first, then moves outward to parent scopes
- **Avoids naming conflicts** across different parts of the program
- **Hash tables** store symbols efficiently, and **linked lists** are used to handle hash collisions.

#### Visibility Rules:
- A variable declared in an **outer scope is visible to all inner scopes**
- A variable declared in an **inner scope is NOT visible outside that scope**

---

### Type-Checking - Strongly-Typed C

The VeSPA compiler implements a **strongly-typed subset of the C language**, which is more restrictive than standard C.

In **standard C**, the language is considered **weakly typed**, meaning many implicit or unsafe type conversions are allowed (sometimes with just a warning). This flexibility is powerful but can result in undefined behavior.

In **VeSPA C**, the compiler enforces stricter rules, so if a type is incorrect or incompatible, **the program will not compile**.

### Enforced Type Rules

- Array indices must be of type `INT`, `SHORT`, or `LONG`
- Increment (`++`) and decrement (`--`) operations are only valid on variables and pointers
- `switch` and `case` conditions must evaluate to `INT` or `CHAR`
- Conditions in `if`, `while`, `do-while`, `switch`, and ternary (`?:`) **cannot be of type `STRING`**
- Bitwise operators (`&`, `|`, `^`, `<<`, `>>`) only accept operands of type `INT`, `CHAR`, `SHORT`, or `LONG`
- Division by zero is not allowed
- Assigning a pointer to another pointer is allowed
- Assigning the address of a variable to a pointer is allowed
- Assigning a `STRING` to a `CHAR*` pointer is allowed
- Assigning an `INT` value to a `CHAR` variable is allowed
- Pointer typecasting is allowed

---

## Constant Folding Optimization

Constant folding is an optimization that checks the AST for operations where all operands are constants.  
If possible, it evaluates the result at compile time so the code generation phase has fewer nodes to process.

### Example

**Before:**
```
       (-)
      /   \
    (+)     10
   /   \
  x     (*)
       /   \
      3     7
```

**After**
```
       (-)
      /   \
    (+)     10
   /   \
  x     21
```
---

## VeSPA ABI ‚Äì Application Binary Interface

The **Application Binary Interface (ABI)** defines how the code generated by the compiler interacts with the VeSPA hardware.  
It acts as an agreement between the **CPU architecture** and the **compiler**, ensuring that both interpret function calls, register usage, data formats and memory structures in a consistent manner.

This ABI specifies:

- Memory organization
- Register usage conventions
- Function calling conventions and stack frame layout
- Data representation (endianness, data sizes and alignment)
- Interrupt handling rules

**Full ABI specification** [here](Reports%20and%20Presentation/VeSPA__ABI.pdf).

### Register Usage (as defined in the ABI)

| Register | Purpose                                  | Caller-Saved |
|----------|-------------------------------------------|--------------|
| **R0**   | Constant zero (hardwired)                | ‚Äì            |
| **R1**   | Return address for function calls        | Yes          |
| **R2**   | Frame Pointer (FP)                       | Yes          |
| **R3**   | Stack Pointer (SP)                       | Yes          |
| **R4‚ÄìR5**| Return registers and special registers used for Mul/Div operations | No        |
| **R6‚ÄìR31** | General-purpose temporary registers     | No           |

---
    
## Code Generation

The **Code Generation** phase is the final stage of the compiler.  
Its goal is to translate the validated Abstract Syntax Tree (AST) into **target assembly code** or **machine code** for execution.

Code Generation main flowchart is shown below

<p align="center">
  <img src="Images/FlowChartGenCode.png" alt="FlowChartGenCode.png" width="190">
</p>

---

### Initialization Code

Before generating instructions for user-defined functions or statements, the compiler emits a small block of **initialization code** to properly set up the runtime environment.

- Place a `JMP` instruction at address `0x00` to jump to the initialization block located at `0x40`.
- Initialize the **Stack Pointer (R2)** and **Frame Pointer (R3)** to the top of the stack (address `1023`).
- Preload the **Return Address Register (R1)** with the address of a `HALT` instruction and push it onto the stack.  
  This ensures that when `main()` finishes execution, the program halts.
- Load a register with the address/label of the `main` function and jump to it.

```
.org 0x00
JMP R0, #64 ; Jump to initialization code at 0x40

.org 0x4000
HALT ; Stop execution

.org 0x40
LDI R2, #1023 ; Stack Pointer = top of stack
LDI R3, #1023 ; Frame Pointer = top of stack
LDI R1, #16384 ; Return address pointing to HALT
SUB R3, R3, #1 ; Adjust stack for storing return address
STX R1, R3, #0 ; Push return address onto stack
LDI R31, :FUNCTION_main
JMP R31, #0 ; Jump to main function

```
---

### Multiplication and Division function code generation

The baseline **VeSPA ISA** does not include native instructions for multiplication, division, or modulus.  
To support these operations, the compiler generates calls to **custom assembly functions**.

**How It Works**
- Multiplication, division, and modulus are **not hardware-supported**.
- These operations are implemented as **software routines** (assembly functions).
- When the compiler encounters `*`, `/`, or `%` in the AST, it generates a **function call** to these routines.
- These routines are generated in the beggining of the code generation step

**Algorithms Used**

| Operation | Algorithm |
|-----------|-----------|
| Multiplication | Shift-and-add multiplication |
| Division & Modulus | Restoring division algorithm |

---
### Stack and Global Variables Management

To support **function calls, local variables, recursion** and **parameter passing**, the compiler implements a **stack-based execution model** that follows the **ABI (Application Binary Interface)**.

### Stack Behavior

- The **stack grows downward**, toward lower memory addresses.  
- **R3 ‚Äì Stack Pointer (SP)** always points to the top of the stack.  
- **R2 ‚Äì Frame Pointer (FP)** marks the base address of the current stack frame.  
- Each function call creates a new **stack frame**, enabling recursion and nested calls.

### Global Variables

- Global variables are stored at the **bottom of RAM**, starting from **0x00**.  
- They are persistent throughout program execution and do not reside on the stack.

---

<div style="display: flex; gap: 20px; align-items: flex-start;">

  <!-- Left Table -->
  <div style="flex: 1;">
    <h3>Parameter Passing and Return Values</h3>
    <table>
      <thead>
        <tr>
          <th>Mechanism</th>
          <th>Convention</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Argument passing</strong></td>
          <td>All function parameters are passed on the <strong>stack</strong>.</td>
        </tr>
        <tr>
          <td><strong>Access location</strong></td>
          <td>First argument at <strong>FP + 1</strong>, second at <strong>FP + 2</strong>, etc.</td>
        </tr>
        <tr>
          <td><strong>Return value</strong></td>
          <td>Stored in <strong>R4</strong>, as defined by the ABI.</td>
        </tr>
        <tr>
          <td><strong>Special case (Mul/Div)</strong></td>
          <td>Parameters passed via <strong>R4</strong> and <strong>R5</strong> for efficiency.</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Right Table -->
  <div style="flex: 1;">
    <h3>Stack Frame Layout</h3>
    <table>
      <thead>
        <tr>
          <th>Section</th>
          <th>Address (relative to FP)</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Arguments</strong></td>
          <td>FP + 1, FP + 2, ‚Ä¶</td>
          <td>Parameters from the caller</td>
        </tr>
        <tr>
          <td><strong>Return Address</strong></td>
          <td>FP - 1</td>
          <td>Address to resume execution</td>
        </tr>
        <tr>
          <td><strong>Previous FP</strong></td>
          <td>FP</td>
          <td>Saved frame pointer of the caller</td>
        </tr>
        <tr>
          <td><strong>Local Variables</strong></td>
          <td>FP - 2, FP - 3, ‚Ä¶</td>
          <td>Function-local variables</td>
        </tr>
      </tbody>
    </table>
  </div>

</div>

<div align="center">
  <img src="Images/StackDesign1.png" alt="Stack Frame 1" width="30%">
  <img src="Images/StackDesign2.png" alt="Stack Frame 2" width="68%">
</div>

**Function Call Sequence**

- Caller pushes **arguments** onto the stack.  
- Caller pushes the **return address**.  
- Current **FP is saved**, and FP is updated to SP.  
- Callee reserves space for **local variables** (SP = SP ‚Äì size).  
- On return:
  - Local variables are freed (SP restored).  
  - Previous FP and return address are restored.  
  - Control returns to the caller.

**This stack design ensures:**
- Support for **recursion and nested calls**  
- Separation of **local** and **global** data  
- ABI-compliant **parameter passing and return values**  
- A **caller‚Äìcallee structure** for code generation, prologues and epilogues  

---

### AST Code generation



